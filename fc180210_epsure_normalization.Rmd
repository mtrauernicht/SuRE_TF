---
title: "EP-SuRE - Data summarization and normalization + cooperativity measures"
author: "FC"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    theme: journal #cerulean
    highlight: monochrome
    toc: true
    toc_float: true
    code_folding: show
editor_options: 
  chunk_output_type: console
---

```{r knitr setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, cache = TRUE, fig.align = 'center', fig.width = 5, fig.height = 5)
```

```{r libs and fun, include = FALSE}
library(tidyverse)
library(magrittr)
library(reshape2)
library(ggplot2)
library(GGally)
library(scales)
library(here)
```
---

## Aims

Here, we summarize EP-SuRE barcode expression and plasmid copy numbers across technical replicates, normalize to library sizes and compute normalized expression values (activities). We then perform barcode summarization. Details can be found in the LaTeX document 'fc180211_epsure_notation_def_cooperativity.tex'.

## Computing activities

```{r load tables, echo = FALSE}
load(here('../data/fc180207_epsure_tibs.RData'))
```

### Summarize technical replicates

We previously verified the high correlation (r > 0.8) between technical replicates of pDNA and cDNA libraries. We therefore summarized technical replicates.

```{r summarize tech replicates, echo = FALSE}
# basal lib
( tib.mg.int.basal %<>%
  select(-ipcr.counts) %>%
  mutate(pdna.counts.1 = pdna.counts.1.1 + pdna.counts.1.2,
         cdna.counts.1 = cdna.counts.1.1 + cdna.counts.1.2,
         cdna.counts.2 = cdna.counts.2.1 + cdna.counts.2.2) %>%
  select(-contains('counts.1.')) %>%
  select(-contains('counts.2.')) )

# coop lib
( tib.mg.int.coop %<>%
  select(-ipcr.counts) %>%
  mutate(pdna.counts.1 = pdna.counts.1.1 + pdna.counts.1.2,
         cdna.counts.1 = cdna.counts.1.1 + cdna.counts.1.2,
         cdna.counts.2 = cdna.counts.2.1 + cdna.counts.2.2) %>%
  select(-contains('counts.1.')) %>%
  select(-contains('counts.2.')) )
```

### Normalize to library sizes

pDNA and cDNA sequencing libraries were sequenced at different depths (see below for records).

```{bash, eval = FALSE}
wc -l #barcodes
6318667 pdna_br1_tr1_barcodes.tsv
5819747 pdna_br1_tr2_barcodes.tsv
2104137 cdna_br1_tr1_barcodes.tsv
2008753 cdna_br1_tr2_barcodes.tsv
2216911 cdna_br2_tr1_barcodes.tsv
1859226 cdna_br2_tr2_barcodes.tsv
```

We therefore rescaled copy number and expression levels to reads per million (rpm).

```{r normalize to library size, echo = FALSE}
lib.sizes <- c('pdna.1' = 6318667 + 5819747,
               'cdna.1' = 2104137 + 2008753,
               'cdna.2' = 2216911 + 1859226) / 1e6

# basal lib
( tib.basal <- tib.mg.int.basal %>%
  mutate(pdna.counts.1 = pdna.counts.1 / lib.sizes['pdna.1'],
         cdna.counts.1 = cdna.counts.1 / lib.sizes['cdna.1'],
         cdna.counts.2 = cdna.counts.2 / lib.sizes['cdna.2']) )

# coop lib
( tib.coop <- tib.mg.int.coop %>%
  mutate(pdna.counts.1 = pdna.counts.1 / lib.sizes['pdna.1'],
         cdna.counts.1 = cdna.counts.1 / lib.sizes['cdna.1'],
         cdna.counts.2 = cdna.counts.2 / lib.sizes['cdna.2']) )
```

### Estimating activities

We study the relation between normalized expression (activity) and plasmid copy number, with the aim of identifying the minimum normalized copy number value resulting in sufficiently stable ratios. Only expressed barcodes were used for this analysis, which was based on normalized copy number values (rpm) deciles.

```{r estimate min copy number, echo = FALSE}
tib.basal %>%
  filter(cdna.counts.1 > 0 & cdna.counts.2 > 0) %>%
  mutate(activity.1 = cdna.counts.1 / pdna.counts.1,
         q = gtools::quantcut(pdna.counts.1, q = seq(0, 1, 0.1))) %>%
  ggplot(aes(x = q, y = activity.1)) + 
    geom_boxplot(aes(color = q), outlier.shape = NA) +
    labs(x = 'Normalized copy number (rpm)', y = 'Normalized activity (expr / copy number)', 
         title = 'Biological replicate 1', subtitle = 'Individual barcodes', color = 'Quantile') +
    coord_cartesian(ylim = c(0, 8)) +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 90))
    
tib.basal %>%
  filter(cdna.counts.1 > 0 & cdna.counts.2 > 0) %>%
  mutate(activity.1 = cdna.counts.1 / pdna.counts.1,
         activity.2 = cdna.counts.2 / pdna.counts.1,
         q = gtools::quantcut(pdna.counts.1, q = seq(0, 1, 0.1))) %>%
  group_by(q) %>%
  summarize(rep1 = sd(activity.1), rep2 = sd(activity.2)) %>%
  melt(value.name = 'sd') %>%
  ggplot(aes(x = q, y = sd, group = variable, color = variable)) +
    geom_point(size = 2) +
    labs(x = 'Normalized copy number (rpm)', y = 'SD normalized activity', 
         title = 'Individual barcodes', color = 'Biol repl') +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 90))
```  

Based on these results, we excluded barcodes in decile 1 from further analyses. This corresponds to a minimum required copy number of ~8 reads (~0.66 rpm). Filtering of basal and combinatorial library based on this value results in 44024 and 319529 barcodes, respectively.

```{r filter out insufficient copy number, echo = FALSE}
( tib.basal %<>%
  filter(pdna.counts.1 >= 0.66) )

( tib.coop %<>%
  filter(pdna.counts.1 >= 0.66) )
```

With these sets, we compute activity values

```{r compute activities, echo = FALSE}
# basal lib
( tib.basal %<>%
  mutate(activity.1 = cdna.counts.1 / pdna.counts.1, activity.2 = cdna.counts.2 / pdna.counts.1) )

# coop lib
( tib.coop %<>%
  mutate(activity.1 = cdna.counts.1 / pdna.counts.1, activity.2 = cdna.counts.2 / pdna.counts.1) )
```

and note that the coefficient of variation of activities plateaus fairly rapidly (~12 barcodes) with barcode counts.

```{r cv activity by number of barcodes, echo = FALSE}
tib.basal %>%
  group_by(id) %>%
  summarize(n = n_distinct(barcode), cv = sd(activity.1) / mean(activity.1)) %>%
  mutate(q = gtools::quantcut(n, seq(0, 1, 0.2))) %>%
  ggplot(aes(x = q, y = cv)) + 
    geom_boxplot(aes(color = q), outlier.shape = NA) +
    labs(x = '#distinct barcodes (quantile)', y = 'CV(activity)', title = 'Biological replicate 1', color = 'Quantile') +
    coord_cartesian(ylim = c(0, 4)) +
    theme_bw()
```

### Summarizing barcodes

Next, we summarize activities across barcodes by considering a weighed average, with weights determined by copy numbers. In our MiSeq run, we know that requiring a minimum number of barcodes for such estimates would dramatically reduce the number of elements and relevant pairs that we can use for downstream analyses of cooperativity. At first, we tried not to impose any threshold on the minimum number of barcodes per fragment but we fear activity values in such situation could be dominated by barcode-intrinsic effects. Therefore, we required >= 8 barcodes for robust averaging, based on the ECDFs below. We also summmarized activity values between biological replicates by their geometric mean.

```{r threshold barcode numbers, echo = FALSE}
# add number of distinct barcodes
# basal lib
tib.tmp <- tib.basal %>%
  group_by(id) %>%
  summarize(n.bc = n_distinct(barcode))

tib.tmp %>%
  ggplot(aes(n.bc)) +
    stat_ecdf() +
    labs(x = '#distinct barcodes', y = 'Fraction of library', title = 'Basal library') +
    geom_vline(xintercept = 8, color = 'skyblue3') +
    theme_bw()

tib.basal %<>% 
  inner_join(tib.tmp, by = 'id')  

# coop lib
tib.tmp <- tib.coop %>%
  group_by(id) %>%
  summarize(n.bc = n_distinct(barcode))

tib.tmp %>%
  ggplot(aes(n.bc)) +
    stat_ecdf() +
    geom_vline(xintercept = 8, color = 'skyblue3') +
    labs(x = '#distinct barcodes', y = 'Fraction of library', title = 'Combinatorial library') +
    theme_bw()

tib.coop %<>% 
  inner_join(tib.tmp, by = 'id')

# filter libraries, keep >=8 barcodes/fragment
tib.basal %<>%
  filter(n.bc >= 8)
tib.coop %<>%
  filter(n.bc >= 8)
```

```{r summarize barcodes, echo = FALSE}
# basal lib
( tib.basal %<>%
  group_by(id, frag1, strand1, frag2, strand2) %>%
  summarize(activity.b1 = sum(pdna.counts.1 * activity.1) / sum(pdna.counts.1),
            activity.b2 = sum(pdna.counts.1 * activity.2) / sum(pdna.counts.1),
            activity.b = sqrt(activity.b1 * activity.b2)) %>%
    ungroup)

# coop lib
( tib.coop %<>%
  group_by(id, frag1, strand1, frag2, strand2) %>%
  summarize(activity.c1 = sum(pdna.counts.1 * activity.1) / sum(pdna.counts.1),
            activity.c2 = sum(pdna.counts.1 * activity.2) / sum(pdna.counts.1),
            activity.c = sqrt(activity.c1 * activity.c2)) %>%
  ungroup)
```

We then analyze the correlation between activities in biological replicates.

```{r correlate activities bw biol repl, echo = FALSE}
tib.basal %>%
  ggplot(aes(activity.b1, activity.b2)) +
    geom_point(alpha = 0.25) +
    geom_smooth(method = 'lm') +
    coord_cartesian(xlim = c(0, 10), ylim = c(0, 10)) +
    labs(x = 'Activity (rep 1)', y = 'Activity (rep 2)', title = 'Basal library', subtitle = 'Summarized barcodes') +
    annotate(x = 0.5, y = 10, label = paste0('r = ', signif(cor(tib.basal$activity.b1, tib.basal$activity.b2), 3)), 
         geom = 'text', size=5) +
    theme_bw()

tib.coop %>%
  ggplot(aes(activity.c1, activity.c2)) +
    geom_point(alpha = 0.05) +
    geom_smooth(method = 'lm') +
    coord_cartesian(xlim = c(0, 30), ylim = c(0, 30)) +
    labs(x = 'Activity (rep 1)', y = 'Activity (rep 2)', title = 'Combinatorial library', subtitle = 'Summarized barcodes') +
    annotate(x = 0.5, y = 30, label = paste0('r = ', signif(cor(tib.coop$activity.c1, tib.coop$activity.c2), 3)), 
         geom = 'text', size = 5) +
    theme_bw()
```

## Computing cooperativity measures

We use the activity values estimates above to compute two different cooperativity indices:
    
1. Additivity: this measure tests whether a pair of regulatory elements exhibits a stronger activity than the expected additive effect given by the sum of the individual activities.
2. Highest single activity: this measure tests whether a pair of regulatory elements has a stronger effect than each of the two components in isolation.

```{r compute cooperativity, echo = FALSE}
( tib.coop %<>%
    # add two tmp ids matching basal library id for each element of pair
    mutate(id.frag1 = paste0(frag1, strand1, frag1, strand1), id.frag2 = paste0(frag2, strand2, frag2, strand2)) %>%
    # extract activities basal frag 1
    inner_join(select(tib.basal, id, activity.b1, activity.b2, activity.b), 
             by = c("id.frag1" = "id")) %>%
    rename(activity.frag1.1 = activity.b1, activity.frag1.2 = activity.b2, activity.frag1 = activity.b) %>%
    # extract activities basal frag 2
    inner_join(select(tib.basal, id, activity.b1, activity.b2, activity.b),
             by = c('id.frag2' = 'id')) %>%
    rename(activity.frag2.1 = activity.b1, activity.frag2.2 = activity.b2, activity.frag2 = activity.b) %>%
    # remove tmp ids
    select(-c(id.frag1, id.frag2)) %>%
    # group by identity
    group_by(id, frag1, strand1, frag2, strand2) %>%
    # compute additive and hsa cooperativity
    mutate(coop.add.1 = log2( (1 + activity.c1) / (1 + activity.frag1.1 + activity.frag2.1) ),
         coop.add.2 = log2( (1 + activity.c2) / (1 + activity.frag1.2 + activity.frag2.2) ),
         coop.add = log2( sqrt(2^coop.add.1 * 2^coop.add.2) ),
         coop.hsa.1 = log2( (1 + activity.c1) / (1 + max(activity.frag1.1, activity.frag2.1)) ),
         coop.hsa.2 = log2( (1 + activity.c2) / (1 + max(activity.frag1.2, activity.frag2.2)) ),
         coop.hsa = log2( sqrt(2^coop.hsa.1 * 2^coop.hsa.2) )) %>%
    ungroup )
```


## SessionInfo

```{r}
sessionInfo()
```
