---
title: "MMA190503_SplitDesignExploratoryAnalysis"
author: "MMA"
date: "3-5-2019"
output: 
  html_document: 
    toc: true
    toc_float: true
    code_folding: show
---
```{r knitr setup, include=FALSE}
prefix_lab <- 'dat_klf2_smk_to_coop_dattero'
knitr::opts_chunk$set(echo = TRUE,
                      include = TRUE,
                      message = FALSE, 
                      warning = FALSE, 
                      cache.path = paste0('cache/', prefix_lab, '/'),
                      fig.path   = paste0('figures/', prefix_lab, '/'),
                      fig.align = 'center', 
                      knitr.table.format = 'markdown')
```

```{r libs and fun, include=FALSE, tidy=FALSE}
#load libraries
library(tidyverse)
library(magrittr)
library(reshape2)
library(knitr)
library(datteRo)
library(GGally)
library(ggplot2)
library(gridExtra)
library(GGally)
library(scales)
library(heatmaply)
library(here)
library(ggpubr)

```

---
## Intro

In this document I amd doing a first exploratory analysis of the Split design data and comparing it to the EP-SuRE data (To which I also refer as Direct ligation approach). The data was processed with same normalizations in both cases. The barcodes were sumarised using an aritmetic mean and using minimum 5 barcodes and 8 pDNA counts per barcode per combination. The EP-SuRe data is only coming from the Klf2 library, as the Split design was based on this library. Therefore, the two datasets are partially overlaping. 

## load Data sets

```{r load data}
#load klf2 EP-SuRE tibs and rename them (Data generated normalisation to pDNA counts of identified elements)
load('~/mydata/GitLab/gurten/gurten/output/fc190228_epsure_tibs_klf2.RData')
tibs_b1_Klf2_EPSuRE <- tibs_b1
tibs_b2_klf2_EPSuRE <- tibs_b2
tibs_minus_lif_klf2_EPSuRE <- tibs_minus_lif

#load Split Design tibs
load('~/mydata/GitLab/epmatrix/data/MMA190502_Split_tibs_avg.RData')

```

### Make tibs for comparison between the two setups with the 3 libraries

```{r combined tibs}
#Basal Merged Data
tibs_b2_Basal_plus <- tibs_b2_klf2_EPSuRE$basal %>% filter(strand == "+")
Basal_ComparisonMerged <- left_join(tib_Split_Basal_Activities,tibs_b2_Basal_plus, by = c("frag2" = "frag" ))

#Combinatorial Merged Data

tibs_b2_Comb <-  tibs_b2_klf2_EPSuRE$comb_all %>% filter(id %in% tib_Split_avg$id)

tib_Split_avg_renamed <- tib_Split_avg %>%
                                     dplyr::rename(
                                     activity_frag2_br1_Split=activity_frag2_br1, 
                                     activity_frag2_br2_Split=activity_frag2_br2, 
                                     activity_frag2_br3_Split=activity_frag2_br3, 
                                     activity_frag2_all_split=activity_frag2_all,
                                     activity_br1_Split=activity_br1, 
                                     activity_br2_Split=activity_br2, 
                                     activity_br3_Split=activity_br3, 
                                     activity_all_split=activity_all,
                                     boost_Split=boost) %>%
                                     select(id,id1, id2, frag1, strand1, activity_frag2_br1_Split,activity_frag2_br1_Split, activity_frag2_br2_Split,
                                            activity_frag2_br3_Split, activity_frag2_all_split,activity_br1_Split, activity_br2_Split, activity_br3_Split, 
                                            activity_all_split, boost_Split)

Combinatorial_ComparisonMerged <- left_join(tibs_b2_Comb ,tib_Split_avg_renamed, by = "id")

#Combinatorial swap Enhancer orientation
tib_Split_avg_renamedchangesing <-tib_Split_avg_renamed %>% mutate( strand1= ifelse(strand1 == "+", "-", "+"))
Combinatorial_ComparisonMergedSwitched<- left_join(tibs_b2_Comb ,tib_Split_avg_renamedchangesing , by = c("frag1", "id2", "strand1"))



```

## Analyses

### Compare Basal activities

The first thing we can check are how the basal activities compare between the two assays. 
Simply plot activity (split) vs activity(EP-SuRE):

```{r, fig.width = 10, fig.height = 9}
Basal_ComparisonMerged %>%
ggplot(aes(log2(activity_frag2_all), log2(activity_all))) +
   geom_jitter(size=1.5, alpha=1, aes(color=frag2)) +
    xlab('#basal Activity Split (log2)') +
    ylab('#Combinatorial EP-SuRE (log2)') +
    ggtitle("Basal Activity Split vs EP-SuRE") +
  geom_smooth(method="lm")+
    stat_cor(method = "pearson")+
    theme_bw(base_size=25) + 
  geom_abline(slope=1)+
    ylim(-3, 5) + 
    xlim(-3, 5) +
    coord_fixed(ratio = 1)
```

We can see there is a relationship between the two activity measures, although there is no identity. Dots lie above the diagonal, meaning that the activities in the EP-SuRE are generally higher than in the Split Design, this might be because the dynamic ranges of both assays are different and therefore activities are relative to each assay. This is probably caused by the composition of the transfected libraries and the fact thar activities are relative measures within each sample. In EP-SuRE most of the elements measured have very little or no activity, whereas in the Split design most of the elements are active, this causes that the distribution of reads, and therefore, the activities ranges are different.

We would expect to find a relationship between the activities of both assays, however, the relationship is not perfect. in order to see it more clearly we ca plot the activities differently:

```{r, fig.width = 10, fig.height = 9}

# another Basal Merged Data
tibs_b2_Basal_plus2 <- tibs_b2_klf2_EPSuRE$basal %>% 
  filter(strand == "+") %>% 
  filter(frag %in% c("P001", "P009", "P013", "P014", "P016", "P017", "P018", "P019", "P021", "P022"))  %>% 
  mutate(Source="EP-SuRE")

tib_Split_Basal_Activities_renamed <- tib_Split_Basal_Activities %>%
                                     dplyr::rename(activity_br1=activity_frag2_br1, 
                                     activity_br2=activity_frag2_br2, 
                                     activity_br3=activity_frag2_br3, 
                                     activity_all=activity_frag2_all,
                                     frag=frag2 ) %>%
                                     mutate(Source="Split")

Basal_ComparisonMerged2 <- bind_rows(tib_Split_Basal_Activities_renamed,tibs_b2_Basal_plus2)

  Basal_ComparisonMerged2 %>%
      mutate(activity_br1=log2(activity_br1))%>%
  mutate(activity_br2=log2(activity_br2))%>%
  mutate(activity_br3=log2(activity_br3))%>%
 mutate(stDev = apply(.[(1:3)],1,sd))%>%
  ggplot(aes(frag, log2(activity_all), color=Source))+
  geom_point(position = "dodge" , stat = "identity")+
        ylab('#comb activity (Split)log2)') +
        xlab('#Promoter') +   
        ggtitle("Basal Activity per promoter") +
        geom_errorbar(aes(ymin=log2(activity_all)-stDev, ymax=log2(activity_all)+stDev), colour="black", width=.1) +
        theme_bw(base_size=20) 


```

In this plot we observe that the promoters that in EP-SuRE have the highest or lowest activities tend to be also the most active or th least active in the Split Design. Nevertheless, this is not true for all of them. Furthermore, we have 6 promoters (P009, P013, P014, P016, P017 and P018) that in EP-Sure have very different activities and in the Split design have very similar activities.

This kind of variation could be explained by a variety of factors:

* Different assay. The PCRs used to measure cDNA and pDNA levels use different primers and strategies. Therefore different aplification efficiencies and biases might lead to different activity measures. Also the position of the barcode that we use to measure expression is different. In the EP-SuRE it is right before the ORF and in the Split design it is right after. As we measure the barcodes in total RNA, it could be that in EP-SuRE we measure nascent transcription, whereas in Split design we might measure stable RNA levels.
* Different Nr of barcodes. Basal activities have low standard deviations due to the fact that each element is charachterised by thousands of barcodes. Low barcode numbers and copy numbers in EP-SuRE might introduce activity biases.
* Different sensitivity. Together with having more barcodes per element in the Split design, these libraries are less complex and more deeply sequenced for the pDNA and cDNA data, meaning that their sensitivity should be higher.
* Different dynamic range. As mentioned before, because the activities values depend on the activities of all elements, the dynamic ranges of each assay are different. This might distort the rankings in each assay.
* Different polyA. The most different feature between the two reporter plasmids is the pA signal placed downstream of the reporter gene, there is a small one in the SuRE setting, whereas in the Split design there are 2, a small one before the query cloning site and a bigger one composed of 3 smaller ones downsteam of the query cloning site. This could affect RNA stability or output of the reporter.

### Compare Combinatorial activities

We can extend the same analysis to the combinatorial activities.
Here again, we plot activity (split) vs activity(EP-SuRE) and color dots by promoter:
```{r, fig.width = 20, fig.height = 18}
Combinatorial_ComparisonMerged %>%
ggplot(aes(log2(activity_all_split), log2(activity_all))) +
   geom_jitter(size=1.5, alpha=1, aes(color=frag2)) +
  facet_wrap(~class) +
    xlab('#comb activity Split') +
    ylab('#comb activity EP-SuRE') +
    ggtitle("Comb activity Split vs EP-SuRE") +
    theme_bw(base_size=25) + 
  geom_abline(slope=1)+
  stat_cor(method = "pearson")+
  geom_smooth(method = lm)+
    geom_hline(yintercept = 0)+
    geom_vline(xintercept = 0)+
    coord_fixed(ratio = 1)
```
```{r, fig.width = 20, fig.height = 18}
Combinatorial_ComparisonMergedSwitched %>%
ggplot(aes(log2(activity_all_split), log2(activity_all))) +
   geom_jitter(size=1.5, alpha=1, aes(color=frag2)) +
  facet_wrap(~class) +
    xlab('#comb activity Split') +
    ylab('#comb activity EP-SuRE') +
    ggtitle("Comb activity Split vs EP-SuRE") +
    theme_bw(base_size=25) + 
  geom_abline(slope=1)+
  stat_cor(method = "pearson")+
  geom_smooth(method = lm)+
    geom_hline(yintercept = 0)+
    geom_vline(xintercept = 0)+
    coord_fixed(ratio = 1)
```
We can see the same trend as before, there is a relationship betwen EP-SuRE and Split activties although it is not perfect, and off the diagonal, meaning EP-SuRE activities are higher than Split activities. By coloring the dots by promoter we see that the combinations of each promoter cluster together meaning that the activity of the combinations is related to the basal activity. Furthermore, these clusters resemble the position of the basal activities per promoter in the first plot. Again this suggests that activities are not directly comparable between assays. Neverteless, as the combinatorial activities within assays are related to basal activities, we should be able to compare boosting indexes (relationship between combinatorial and basal ativity within the same assay) to check if interactions have the same sign in both assays.


Next, we can look at how combinatorial and basal activities are distributed by plotting Combinatorial activity vs Basal activity of the Promoter.

```{r, fig.width = 20, fig.height = 18}
tib_Split_avg %>%
ggplot(aes(log2(activity_frag2_all), log2(activity_all))) +
   geom_jitter(size=1.5, alpha=1,aes(color=frag2)) +
    xlab('#basal Activity frag2 (log2)') +
    ylab('#Combinatorial activity (log2)') +
    ggtitle("Basal Activity vs comb activity, Split") +
    theme_bw(base_size=25) + 
  geom_abline(slope=1)+
        stat_function(fun = (function(x)log2(2*2^(x))), colour = "black")+
      stat_function(fun = (function(x)log2(2^(x)/2)), colour = "black")+
    coord_fixed(ratio = 1)
```

```{r, fig.width = 20, fig.height = 18}
Combinatorial_ComparisonMerged %>%
ggplot(aes(log2(activity_frag2_all_split), log2(activity_all_split))) +
  facet_grid(strand1.x~class) +
   geom_jitter(size=1.5, alpha=1,aes(color=log2(activity_all_frag1))) +
    xlab('#basal Activity frag2 (log2)') +
    ylab('#Combinatorial activity (log2)') +
    ggtitle("Basal Activity vs comb activity, Split") +
    theme_bw(base_size=25) + 
  geom_abline(slope=1)+
  stat_function(fun = (function(x)log2(2*2^(x))), colour = "black")+
  stat_function(fun = (function(x)log2(2^(x)/2)), colour = "black")+
  coord_fixed(ratio = 1)
```
This plot shows a data distribution that we have seen before , vertical lines which represent all the combinations of each promoter.
For comparisons we can make the same plot for the EP-SuRE data.

```{r, fig.width = 20, fig.height = 18}
tibs_b2$comb_all %>%
  filter(class=="EP") %>%
ggplot(aes(log2(activity_all_frag2), log2(activity_all))) +
   geom_jitter(size=1.5, alpha=1,aes(color=frag2)) +
    xlab('#basal Activity Promoter (log2)') +
    ylab('#Combinatorial activity (log2)') +
    ggtitle("Basal Activity vs comb activity, EP-SuRE") +
    theme_bw(base_size=25) + 
  geom_abline(slope=1)+
        stat_function(fun = (function(x)log2(2*2^(x))), colour = "black")+
      stat_function(fun = (function(x)log2(2^(x)/2)), colour = "black")+
    coord_fixed(ratio = 1)
```
Now the same for promoters in the split design.
```{r, fig.width = 20, fig.height = 18}
tibs_b2_klf2_EPSuRE$comb_all %>%
  filter(class=="EP") %>%
  filter(strand2=="+") %>%
  filter(frag2 %in% c("P001","P009","P013","P014","P016","P017","P018","P019","P021","P022"))%>%
ggplot(aes(log2(activity_all_frag2), log2(activity_all))) +
   geom_point(size=1.5, alpha=1,aes(color=frag2)) +
    xlab('#basal Activity Promoter (log2)') +
    ylab('#Combinatorial activity (log2)') +
    ggtitle("Basal Activity vs comb activity, EP-SuRE") +
    theme_bw(base_size=25) + 
  geom_abline(slope=1)+
        stat_function(fun = (function(x)log2(2*2^(x))), colour = "black")+
      stat_function(fun = (function(x)log2(2^(x)/2)), colour = "black")+
    coord_fixed(ratio = 1)
```
```{r, fig.width = 20, fig.height = 18}
tibs_b2_klf2_EPSuRE$comb_all %>%
  filter(class=="EP") %>%
  filter(strand2=="+") %>%
  filter(frag2 %in% c("P001","P009","P013","P014","P016","P017","P018","P019","P021","P022"))%>%
ggplot(aes(log2(activity_all_frag2), log2(activity_all))) +
   geom_jitter(size=1.5, alpha=1,aes(color=frag2)) +
    xlab('#basal Activity Promoter (log2)') +
    ylab('#Combinatorial activity (log2)') +
    ggtitle("Basal Activity vs comb activity, EP-SuRE") +
    theme_bw(base_size=25) + 
  geom_abline(slope=1)+
        stat_function(fun = (function(x)log2(2*2^(x))), colour = "black")+
      stat_function(fun = (function(x)log2(2^(x)/2)), colour = "black")+
    coord_fixed(ratio = 1)
```

In these plots we can observe again that the position of each promoter column with respect to each other is different, due to the changes in basal activities between assays. If we compare the plots from each assay it seems that there might be mopre dots above the diagonal in the Split data than in the EP-SuRE data, meaning that boosting may be more frequent in the Split setup. However, this is not the proper way to check it, for this we move to look at the boosting indexes.


### Compare Boosting indexes

First step is to look at the EP matrix for the boosting index.

#### Split Boosting index Matrix 

```{r ploot matrix function, include=FALSE}

#Function to plot the Boosting index Matrix 
plot_coop_heatmap_split <- function(tib, classs = 'all' , skip_n_lab = 1) {

  # validate args
  if(!classs %in% c('all', 'EE', 'EP', 'PE', 'PP', 'EN', 'PN'))
    stop('Undefined class type. Please use one of EE, EP, PE or PP, or leave default for all pairs')

  if(classs != 'all') {
    # note: tib %>% filter(class == get('class')) fails
    # see https://stackoverflow.com/questions/40169949/filter-dataframe-using-global-variable-with-the-same-name-as-column-name

    tib     <- tib %>% filter(class %in% classs)
  }

  # set color palette
  pal <- c('navyblue', 'gray95', 'orangered')

  # static viz


      # compute coop index range
      y_min <- min(tib[['boost']], na.rm = TRUE)
      y_max <- max(tib[['boost']], na.rm = TRUE)

      # coop index heatmap (additive)
      p_main <- tib %>%
        ggplot(aes(x = id1, y = id2)) +
        geom_tile(fill = 'gray40') +
        #        geom_tile(color = 'gray20', alpha = 0, size = 0.5) + ## prev version with stroke
        #        geom_tile(fill = rgb(53/255, 143/255, 168/255, 0.1)) + ## prev version with color outside coop idx palette
        geom_raster(data = tib, aes(x = id1, y = id2, fill = boost))

    


    # marginal barplots
      
      tib_p_top <- tib %>%
      select(id1, activity_all_frag1) %>%
      distinct() %>%
      mutate(activity_orig = log2(activity_all_frag1),
             shift    = min(activity_orig[!is.infinite(activity_orig)], na.rm = TRUE),
             activity = activity_orig + abs(shift))
      
    p_top <- tib_p_top %>%
      ggplot(aes(id1, activity)) +
      geom_bar(stat = 'identity') +
      scale_y_continuous(breaks = c(min(tib_p_top[['activity']][!is.infinite(tib_p_top[['activity']])]),
                                    max(tib_p_top[['activity']])),
                         labels = c(signif(min(tib_p_top[['activity_orig']][!is.infinite(tib_p_top[['activity_orig']])]), 2),
                                    signif(max(tib_p_top[['activity_orig']]), 2)))

    tib_p_right <- tib %>%
      select(id2, activity_frag2_all) %>%
      distinct() %>%
      mutate(activity_orig = log2(activity_frag2_all),
             shift    = min(activity_orig[!is.infinite(activity_orig)], na.rm = TRUE),
             activity = activity_orig + abs(shift))

    p_right <- tib_p_right %>%
      ggplot(aes(id2, activity)) +
      geom_bar(stat = 'identity') +
      scale_y_continuous(breaks = c(min(tib_p_right[['activity']][!is.infinite(tib_p_right[['activity']])]),
                                    max(tib_p_right[['activity']])),
                         labels = c(signif(min(tib_p_right[['activity_orig']][!is.infinite(tib_p_right[['activity_orig']])]), 2),
                                    signif(max(tib_p_right[['activity_orig']]), 2))) +
      coord_flip()

    # cosmetics
    p_main <- p_main +
      scale_fill_gradientn(colors = pal,
                           values = rescale(c(y_min, 0, y_max))) +
      labs(x = 'First element', y = 'Second element', fill = 'boostIndex', caption = paste0('(n = ', nrow(tib), ' pairs)')) +
      theme(axis.text.x      = element_text(angle = 90, color =  c('black', rep('transparent', skip_n_lab))),
            axis.text.y      = element_text(color =  c('black', rep('transparent', 1))),
            panel.grid       = element_blank(),
            panel.background = element_rect(fill = "white"),
            legend.position  = 'bottom',
            text             = element_text(size = 13),)

    p_top <- p_top +
      labs(x = NULL,  y = 'EP-SuRE (log2)') +
      theme_bw() +
      theme(axis.line.x  = element_line(size = 0, colour = "white"),
            axis.ticks.x = element_line(size = 0),
            axis.text.x  = element_blank(),
            panel.border = element_blank(),
            panel.grid   = element_blank(),
            text         = element_text(size = 13))
    
    p_right <- p_right +
      labs(x = NULL,  y = 'Basal Split (log2)') +
      theme_bw() +
      theme(axis.line.y  = element_line(size = 0, colour = "white"),
            axis.ticks.y = element_line(size = 0),
            axis.text.y  = element_blank(),
            panel.border = element_blank(),
            panel.grid   = element_blank(),
            text         = element_text(size = 13))

    p_empty <- ggplot(mtcars, aes(wt, mpg)) +
      theme(line             = element_blank(),
            text             = element_blank(),
            title            = element_blank(),
            panel.background = element_rect(fill = NA, size = 0), plot.background = element_rect(size = 0))
    egg::ggarrange(p_top,
                   p_empty,
                   p_main,
                   p_right,
                   nrow = 2,
                   ncol = 2,
                   widths = c(3, 1),
                   heights = c(1, 3))



}
```

```{r, fig.height=20 , fig.width=30, include=FALSE}
#add EP-SuRE fragment 1 basal activity
tibs_b2_Basal <- tibs_b2_klf2_EPSuRE$basal %>% select(id, activity_all) %>% dplyr::rename(activity_all_frag1=activity_all)
tib_Split_avg_basalFrag1 <- left_join(tib_Split_avg,tibs_b2_Basal, by = c("id1" = "id" ))
#make plot
EPMatrix <- plot_coop_heatmap_split(tib_Split_avg_basalFrag1, class = c('EP', 'EN'), skip_n_lab = 0)
```
```{r, fig.width = 30, fig.height = 18}
#Add title
annotate_figure(EPMatrix,
                top = text_grob("Boost Matrix EP pairs Split Design", size = 30))
```
**Note that the basal activity of the promoters (second element) comes from the Split design, whereas the basal activity for the enhancers comes from EP-SuRE and is ploted to just have a sense of transcriptional activity**

Luckily, now we have an almost full EP matrix. First thing we can spot is that boosting remains specific but patterns arise. Second thing we can spot is that indeed boosting may be more frequent now. (I quantify it below)



Now plot the same adding the PP combinations.
```{r, fig.height=20, fig.width=30, include=FALSE}
AllMatrix <- plot_coop_heatmap_split(tib_Split_avg_basalFrag1, class = 'all', skip_n_lab = 0)
```

```{r, fig.width = 40, fig.height = 30}
annotate_figure(AllMatrix,
                top = text_grob("Boost Matrix All pairs Split Design", size = 30))

```

#### EP-SuRE EP matrix

Ploting EP-SuRE matrices for coop index and boosting index, in order to compare to the previous ones.
```{r}
# second batch (some renaming required for backward compatibility

tib_comb_all_b2_reduced <- tibs_b2_klf2_EPSuRE$comb_all %>%
    mutate(coop_add = coop_add_all)%>%
  filter(frag2 %in% c("P001", "P009", "P013", "P014", "P016", "P017", "P018", "P019", "P021", "P022")) %>%
  filter(strand2=="+") 

tib_comb_b2_reduced <- tibs_b2_klf2_EPSuRE$comb %>%
      mutate(coop_add = coop_add_all)%>%
  filter(frag2 %in% c("P001", "P009", "P013", "P014", "P016", "P017", "P018", "P019", "P021", "P022")) %>%
  filter(strand2=="+") 

```

```{r, fig.width = 30, fig.height = 20}
  plot_coop_heatmap(tib_comb_b2_reduced, tib_comb_all_b2_reduced, class = 'EP', type = 'add', winsorize = TRUE, skip_n_lab = 1)
```
Same for boosting
```{r}
# second batch (some renaming required for backward compatibility

tib_comb_all_b2_reducedheat <-tibs_b2_klf2_EPSuRE$comb_all %>%
    mutate(coop_add = boost_all)%>%
  filter(frag2 %in% c("P001", "P009", "P013", "P014", "P016", "P017", "P018", "P019", "P021", "P022")) %>%
  filter(strand2=="+") 

tib_comb_b2_reducedheat <-tibs_b2_klf2_EPSuRE$comb %>%
      mutate(coop_add = boost_all)%>%
  filter(frag2 %in% c("P001", "P009", "P013", "P014", "P016", "P017", "P018", "P019", "P021", "P022")) %>%
  filter(strand2=="+") 

```

```{r, fig.width = 30, fig.height = 20}
  plot_coop_heatmap(tib_comb_b2_reducedheat, tib_comb_all_b2_reducedheat, class = 'EP', type = 'add', winsorize = TRUE, skip_n_lab = 1)
```

#### Quantify Boosting

Here we simply quantify Boosting the proportion of boosting indexes higher than 0. 

For the split design
```{r}

Allpairs<-tib_Split_avg%>% 
 filter(frag2!="NoP")%>%
  nrow()

Boostedpairs<-tib_Split_avg%>% 
   filter(frag2!="NoP")%>%
  filter(boost>0)%>%
  nrow()

# %of supraadditive cooperative pairs
100*Boostedpairs/Allpairs

```

For the EP-SuRE Data

```{r}


AllpairsEPSuRE <-tibs_b2_Comb %>%
  nrow()

BoostedpairsEPSuRE<-tibs_b2_Comb %>%
  filter(boost_all>0)%>%
  nrow()

# %of supraadditive cooperative pairs
100*BoostedpairsEPSuRE/AllpairsEPSuRE

```

* There is indeed more boosting in the Split design

### Directly compare Boosting indexes
We take the intersection between the two datasets (combinations present in both assays) and compare their boosting indexes. 
```{r, fig.width = 20, fig.height = 18}
Combinatorial_ComparisonMerged %>%
ggplot(aes(boost_Split, boost_all)) +
   geom_jitter(size=1.5, alpha=1, aes(color=log2(activity_all_frag1))) +
  facet_wrap(~class) +
    xlab('#boost Split') +
    ylab('#boost EP-SuRE') +
    ggtitle("Boosting index Split vs EP-SuRE") +
    theme_bw(base_size=25) + 
      stat_cor(method = "pearson")+
  geom_smooth(method = lm)+
  geom_abline(slope=1)+
    geom_hline(yintercept = 0)+
    geom_vline(xintercept = 0)+
    coord_fixed(ratio = 1)
```

We can appreciate there is a general correlation between bosting indexes in both assays but the trend is tilted to the right. There is no identity (same or very similar index) between most indexes but we can apreciate that most indexes remain of the same sign in both assays. 

We can quantify it in the following analysis.

First we can classify combinations acording to the activities in the EP-SuRE assay into Activating(SupAddBoost), Putatively repressed (PutRep), interfering/readthrough interference (Interf), or the rest.

```{r, fig.width = 20, fig.height = 18}
Combinatorial_ComparisonMerged %>%
    mutate(BoostClass= "N") %>%
  mutate(BoostClass= ifelse(boost_all<0 & activity_all>5*activity_all_frag1, "PutRep", 
                        ifelse(
                          coop_add_all<0 & boost_all>0 & activity_all_frag1 > activity_all_frag2, "Interf",
                        ifelse(
                          coop_add_all>0, "SupAddBoost",
                          "Rest")
                        )))%>%
ggplot(aes(boost_Split, boost_all)) +
           geom_rect(aes(xmin = -0.1520, xmax = 0.1375, ymin = -Inf, ymax = Inf),
                   fill = "gray90", alpha = 0.03)+
           geom_rect(aes(ymin = -0.1520, ymax = 0.1375, xmin = -Inf, xmax = Inf),
                   fill = "gray90", alpha = 0.03)+
   geom_jitter(size=1.5, alpha=1, aes(color=BoostClass)) +
  facet_wrap(~class) +
    xlab('#boost Split') +
    ylab('#boost EP-SuRE') +
    ggtitle("Boosting index Split vs EP-SuRE") +
    theme_bw(base_size=25) + 
  geom_abline(slope=1)+
    geom_hline(yintercept = 0)+
    geom_vline(xintercept = 0)+
    coord_fixed(ratio = 1)
```
**Grey areas indicate 10% activity change**

Now we can appreciate that most of putatively repressed pairs remain repressive in the Split design, although a fraction of them are now activating.

Same happens for activating pairs although it seems more of them are transfered to repressing.

We can quantify these trends.

```{r, fig.width = 20, fig.height = 18}
Combinatorial_ComparisonMerged %>%
ggplot(aes(boost_Split, coop_add_all)) +
   geom_jitter(size=1.5, alpha=1, aes(color=log2(activity_all_frag1))) +
  facet_wrap(~class) +
    xlab('#boost Split') +
    ylab('#coop EP-SuRE') +
    ggtitle("Boosting index Split vs coop index EP-SuRE") +
    theme_bw(base_size=25) + 
  geom_abline(slope=1)+      
  stat_cor(method = "pearson")+
  geom_smooth(method = lm)+
    geom_hline(yintercept = 0)+
    geom_vline(xintercept = 0)+
    coord_fixed(ratio = 1)
```
#### Quantify transfered combinations and agreeing combinations

By transfered combinations I mean combinations that have boosting indexes with different signs in each approach.
By agreeing combinations I mean combinations that have boosting indexes with same signs in each approach. 

First we quantify for how many combinations the boosting index agrees in both approaches.

```{r}
# Quantify combinations for which the boosting index has the same sign in both orientations
MergedTot <- Combinatorial_ComparisonMerged %>%
      nrow()

Agree<-Combinatorial_ComparisonMerged %>%
  filter(boost_all>0 &boost_Split>0 | boost_all<0 &boost_Split<0) %>%
  nrow()


100*Agree/MergedTot
```

Quantify Transfer from repressor to activator (EP-SuRe to Split)
```{r}
#Quantify boost_all<0 &boost_Split>0
TransferReptoAct<-Combinatorial_ComparisonMerged %>%
  filter(boost_all<0 &boost_Split>0) %>%
  nrow()


100*TransferReptoAct/MergedTot
```
Quantify Transfer from Activator to repressor (EP-SuRe to Split) using EP-SuRE boost index
```{r}
#Quantify boost_all>0 &boost_Split<0
TransferActtoRep<-Combinatorial_ComparisonMerged %>%
  filter(boost_all>0 &boost_Split<0) %>%
  nrow()


100*TransferActtoRep/MergedTot
```
Quantify Transfer from SupraaditiveActivator to repressor (EP-SuRe to Split)
```{r}
#Quantify coop_all>0 &boost_Split<0
TransferSupActtoRep<-Combinatorial_ComparisonMerged %>%
  filter(coop_add_all>0 &boost_Split<0) %>%
  nrow()


100*TransferSupActtoRep/MergedTot
```

#### Quantify Putative repression

% of combinations represive in Split design
```{r, fig.width = 20, fig.height = 18}
#Filter putative repressors in EP-SuRE
SplitTot<- tib_Split_avg %>%
  nrow()

SplitRep <- tib_Split_avg %>%
    filter(boost<0) %>%
  nrow()

100*SplitRep/SplitTot
```


% of combinations repressive in EP-SuRE design (klf2 lib Ps in Split design)
```{r}


DirectTot<-tibs_b2$comb_all%>%
  filter(frag2 %in% c("P001","P009","P013","P014","P016","P017","P018","P019","P021","P022"))%>%
  filter(strand2=="+")%>%
nrow()

DirectRepressive<-tibs_b2$comb_all%>%
  filter(frag2 %in% c("P001","P009","P013","P014","P016","P017","P018","P019","P021","P022"))%>%
  filter(strand2=="+")%>%
      filter(coop_add_all<0)%>%
  filter(boost_all<0)%>%
      filter(activity_all_frag1<activity_all_frag2)%>%
  nrow()

# % of Repressed  pairs
100*DirectRepressive/DirectTot

```


% of Putative repressors from EP-SuRE combinations that are repressive in both setups
```{r}
#Filter putative repressors in EP-SuRE
Combinatorial_ComparisonMerged_putrepre <- Combinatorial_ComparisonMerged %>%
      filter(boost_all<0 & activity_all>5*activity_all_frag1) 

PutRep<-nrow(Combinatorial_ComparisonMerged_putrepre)

RepRep<-Combinatorial_ComparisonMerged_putrepre %>% filter(boost_Split<0) %>% nrow()

100*RepRep/PutRep
```

Most of the putative repressors are still repressors in the split design.

#### Quantify Putative Supraaditive Boosting

% of combinations Activating in Split design
```{r}

SplitAct <- tib_Split_avg %>%
    filter(boost>0) %>%
  nrow()

100*SplitAct/SplitTot
```
% of combinations boosters in EP-SuRE design (klf2 lib Ps in Split design)

```{r}

DirectBoost<-tibs_b2$comb_all%>%
  filter(frag2 %in% c("P001","P009","P013","P014","P016","P017","P018","P019","P021","P022"))%>%
  filter(strand2=="+")%>%
  filter(boost_all>0)%>%
  nrow()

# % of Supraaditive boosting  pairs
100*DirectBoost/DirectTot
```

% of combinations Supraaditive boosters in EP-SuRE design (klf2 lib Ps in Split design)
```{r}

DirectSupAddBoost<-tibs_b2$comb_all%>%
  filter(frag2 %in% c("P001","P009","P013","P014","P016","P017","P018","P019","P021","P022"))%>%
  filter(strand2=="+")%>%
      filter(coop_add_all>0)%>%
  filter(boost_all>0)%>%
  nrow()

# % of Supraaditive boosting  pairs
100*DirectSupAddBoost/DirectTot
```


% of Supraaditve booster combinations from EP-SuRE that are boosters in both setups
```{r}
#Filter putative repressors in EP-SuRE
Combinatorial_ComparisonMerged_Supboost<- Combinatorial_ComparisonMerged %>%
      filter(coop_add_all>0) 

supboostDir<-nrow(Combinatorial_ComparisonMerged_Supboost)

SupBoostSplit<-Combinatorial_ComparisonMerged_Supboost %>% filter(boost_Split>0) %>% nrow()

100*SupBoostSplit/supboostDir
```

% of EP Supraaditve booster combinations from EP-SuRE that are boosters in both setups
```{r}
#Filter putative repressors in EP-SuRE
Combinatorial_ComparisonMerged_SupboostEP<- Combinatorial_ComparisonMerged %>%
      filter(coop_add_all>0) %>%
  filter(class=="EP")

supboostDirEP<-nrow(Combinatorial_ComparisonMerged_SupboostEP)

SupBoostSplitEP<-Combinatorial_ComparisonMerged_SupboostEP %>% filter(boost_Split>0) %>% nrow()

100*SupBoostSplitEP/supboostDirEP
```

% of boosted combinations from EP-SuRE that are boosters in both setups
```{r}
#Filter putative repressors in EP-SuRE
Combinatorial_ComparisonMerged_boost<- Combinatorial_ComparisonMerged %>%
      filter(boost_all>0) 

boostDir<-nrow(Combinatorial_ComparisonMerged_boost)

BoostSplit<-Combinatorial_ComparisonMerged_Supboost %>% filter(boost_Split>0) %>% nrow()

100*BoostSplit/boostDir
```
% of EP combinations from EP-SuRE that are boosters (without putative interfering pairs) in both setups
```{r}
#Filter putative repressors in EP-SuRE
Combinatorial_ComparisonMerged_boostEP<- Combinatorial_ComparisonMerged %>%
      filter(boost_all>0) %>%
  filter(class=="EP")


boostDirEP<-nrow(Combinatorial_ComparisonMerged_boostEP)

BoostSplitEP<-Combinatorial_ComparisonMerged_boostEP %>% filter(boost_Split>0) %>% nrow()

100*BoostSplitEP/boostDirEP
```

% of EP boosted combinations from EP-SuRE that are boosters (without putative interfering pairs) in both setups
```{r}
#Filter putative repressors in EP-SuRE
Combinatorial_ComparisonMerged_boostEP2<- Combinatorial_ComparisonMerged %>%
      filter(boost_all>0) %>%
  filter(activity_all_frag1<activity_all)


boostDirEP2<-nrow(Combinatorial_ComparisonMerged_boostEP2)

BoostSplitEP2<-Combinatorial_ComparisonMerged_boostEP2 %>% filter(boost_Split>0) %>% nrow()

100*BoostSplitEP2/boostDirEP2
```


Only 66.6% of the supraaditive boosters remain as boosters in the Split design.
Only 20.3% of the  boosters in EP-SuRE remain as boosters in the Split design.
But if we restrict ourselves to EP boosting 63.8% of it is conserved, showing that interference by puting a strong element upstream might be important.
We have the same  same effect if we remove putative interference. In this case 62.5% of boosting is conserved between the two setups.

This confirms that boosting index is only a good estimate in EP-SuRE when the upstream element is weak.


Repression is more conserved than boosting, supraaditive boosting is quite conserved and boosting in EP combinations is also quite conserved. However, the total numbers of boosted pairs are very low.


### Query orientation

#### Split


```{r, fig.width = 10, fig.height = 9}
#Match combinations with Query in both orientations
x <-tib_Split_avg %>%
  filter(strand1=="+")%>%
  select(id,class,id1, frag1,strand1, id2,frag2, strand2, activity_all, activity_frag2_all, boost)
y<-tib_Split_avg %>%
  filter(strand1=="-")%>%
  select(id,class,id1, frag1,strand1, id2,frag2, strand2, activity_all, activity_frag2_all, boost)

 BothOrientationsSplit<-inner_join(x,y, by = c("id2", "frag1"), suffix = c("1","2") )

 BothOrientationsSplit %>%
  filter(class1=="EP")%>%
  ggplot(aes(log2(activity_all1),log2(activity_all2)))+
   geom_jitter(size=0.5, aplpha=0.5)+
     geom_abline(slope=1)+
       stat_cor(method = "pearson")+
        stat_function(fun = (function(x)log2(2*2^(x))), colour = "black")+
      stat_function(fun = (function(x)log2(2^(x)/2)), colour = "black")+
      ggtitle("EP Activity per Enhancer orientation")+
      xlab('#Activity E+ (log2)') +
    ylab('#Activity E-(log2)') +
    coord_fixed(ratio = 1)
```

```{r, fig.width = 10, fig.height = 9}
 BothOrientationsSplit %>%
  ggplot(aes(log2(activity_all1),log2(activity_all2)))+
   geom_jitter(size=0.5, aplpha=0.5)+
     geom_abline(slope=1)+
  facet_wrap(~class1)+
       stat_cor(method = "pearson")+
        stat_function(fun = (function(x)log2(2*2^(x))), colour = "black")+
      stat_function(fun = (function(x)log2(2^(x)/2)), colour = "black")+
      ggtitle("EP Activity per Query orientation")+
      xlab('#Activity Q+ (log2)') +
    ylab('#Activity Q-(log2)') +
    coord_fixed(ratio = 1)
```
```{r, fig.width = 30, fig.height = 27}
BothOrientationsSplit %>%
  ggplot(aes(log2(activity_all1),log2(activity_all2)))+
  geom_jitter(size=0.5, aplpha=0.5)+
  facet_wrap(~id2)+
  geom_abline(slope=1)+
  geom_smooth(method="lm")+
  stat_cor(method = "pearson")+
  stat_function(fun = (function(x)log2(2*2^(x))), colour = "black")+
  stat_function(fun = (function(x)log2(2^(x)/2)), colour = "black")+
  ggtitle("Split Activity per Query orientation")+
  xlab('#Activity Q+ (log2)') +
  ylab('#Activity Q-(log2)') +
  coord_fixed(ratio = 1)
```

```{r, fig.width = 30, fig.height = 27}
tib_Split_avg%>%
  ggplot(aes(log2(activity_br1),log2(activity_br2)))+
  geom_jitter(size=0.5, aplpha=0.5)+
  facet_wrap(~id2)+
  geom_abline(slope=1)+
  geom_smooth(method="lm")+
  stat_cor(method = "pearson")+
  stat_function(fun = (function(x)log2(2*2^(x))), colour = "black")+
  stat_function(fun = (function(x)log2(2^(x)/2)), colour = "black")+
  ggtitle("Split Activity Br1vsBr2")+
  xlab('#Activity Q+ (log2)') +
  ylab('#Activity Q-(log2)') +
  coord_fixed(ratio = 1)
```
```{r, fig.width = 30, fig.height = 27}
BothOrientationsSplit %>%
  ggplot(aes(boost1,boost2))+
  geom_jitter(size=0.5, alpha=0.5)+
  facet_wrap(~frag1)+
  geom_abline(slope=1)+
  geom_smooth(method="lm")+
  stat_cor(method = "pearson")+
  stat_function(fun = (function(x)log2(2*2^(x))), colour = "black")+
  stat_function(fun = (function(x)log2(2^(x)/2)), colour = "black")+
  ggtitle("EP Activity per Query orientation")+
  xlab('#Activity Q+ (log2)') +
  ylab('#Activity Q-(log2)') +
  coord_fixed(ratio = 1)
```

```{r, fig.width = 30, fig.height = 27}
BothOrientationsSplit %>%
  ggplot(aes(log2(activity_all1),log2(activity_all2)))+
  geom_jitter(size=0.5, aplpha=0.5)+
  facet_grid(class1~id2)+
  geom_abline(slope=1)+
  geom_smooth(method="lm")+
  stat_cor(method = "pearson")+
  stat_function(fun = (function(x)log2(2*2^(x))), colour = "black")+
  stat_function(fun = (function(x)log2(2^(x)/2)), colour = "black")+
  ggtitle("EP Activity per Query orientation")+
  xlab('#Activity Q+ (log2)') +
  ylab('#Activity Q-(log2)') +
  coord_fixed(ratio = 1)
```


```{r, fig.width = 10, fig.height = 9}
BothOrientationsSplit %>%
  #filter(id11 %in% BothOrientationsDirect$id11 )%>%
  filter(class1=="EP")%>%
  ggplot(aes(boost1,boost2))+
   geom_jitter(size=0.5, alpha=0.9)+
  facet_wrap(~class1)+
     geom_abline(slope=1)+
       stat_cor(method = "pearson")+
        stat_function(fun = (function(x)log2(2*2^(x))), colour = "black")+
      stat_function(fun = (function(x)log2(2^(x)/2)), colour = "black")+
      ggtitle("EP boosting index per Enhancer orientation Split")+
      xlab('#boost index E+ (log2)') +
    ylab('#boost index E-(log2)') +
  geom_smooth(method=lm)+
    coord_fixed(ratio = 1)
```

```{r eval=FALSE, fig.height=, fig.width=10, include=FALSE}
BothOrientationsSplit %>%
  filter(id11 %in% BothOrientationsDirect$id11 )%>%
  filter(class1=="EP")%>%
  ggplot(aes(boost1,boost2))+
   geom_jitter(size=0.5, alpha=0.9)+
     geom_abline(slope=1)+
       stat_cor(method = "pearson")+
        stat_function(fun = (function(x)log2(2*2^(x))), colour = "black")+
      stat_function(fun = (function(x)log2(2^(x)/2)), colour = "black")+
      ggtitle("EP boosting index per Enhancer orientation, matched dataset")+
      xlab('#boost index E+ (log2)') +
    ylab('#boost index E-(log2)') +
    coord_fixed(ratio = 1)
```


```{r, fig.width = 10, fig.height = 9}
BothOrientationsSplit %>%
  ggplot(aes(boost1,boost2))+
   geom_jitter(size=0.5, aplpha=0.5)+
    facet_wrap(~class1)+
     geom_abline(slope=1)+
       stat_cor(method = "pearson")+
        stat_function(fun = (function(x)log2(2*2^(x))), colour = "black")+
      stat_function(fun = (function(x)log2(2^(x)/2)), colour = "black")+
      ggtitle("EP boosting index per Query orientation")+
      xlab('#boost index Q+ (log2)') +
    ylab('#boost index Q-(log2)') +
    coord_fixed(ratio = 1)
```

```{r, fig.width = 10, fig.height = 9}
#Add basal activties Query from EP-SuRE
BothOrientationsSplitbasal <- left_join(BothOrientationsSplit,tibs_b2_Basal, by = c("id111" = "id" ))
BothOrientationsSplitbasal <- left_join(BothOrientationsSplitbasal,tibs_b2_Basal, by = c("id12" = "id" ))


BothOrientationsSplitbasal %>%
  filter(class1== "PP")%>%
  mutate(ADiff = (log2(activity_all_frag1.x)-log2(activity_all_frag1.y)))%>%
  ggplot(aes(boost1,boost2, color=ADiff))+
   geom_jitter(size=0.5, aplpha=0.5)+
    facet_wrap(~frag1)+
     geom_abline(slope=1)+
       stat_cor(method = "pearson")+
        stat_function(fun = (function(x)log2(2*2^(x))), colour = "black")+
      stat_function(fun = (function(x)log2(2^(x)/2)), colour = "black")+
  scale_color_viridis(name = "log2(P+)-log2(P-)")+
      ggtitle("EP boosting index per Query orientation")+
      xlab('#boost index Q+ (log2)') +
    ylab('#boost index Q-(log2)') +
    coord_fixed(ratio = 1)
```
```{r, fig.width = 10, fig.height = 9}


BothOrientationsSplitbasal %>%
  mutate(ADiff = (log2(activity_all_frag1.x)-log2(activity_all_frag1.y)))%>%
  ggplot(aes(boost1,boost2, color=ADiff))+
   geom_jitter(size=0.5, aplpha=0.5)+
    facet_wrap(~class1)+
     geom_abline(slope=1)+
       stat_cor(method = "pearson")+
        stat_function(fun = (function(x)log2(2*2^(x))), colour = "black")+
      stat_function(fun = (function(x)log2(2^(x)/2)), colour = "black")+
    scale_color_gradient2(low = "navyblue", mid = "grey100", high = "red") +
  #scale_color_viridis(name = "log2(P+)-log2(P-)")+
      ggtitle("EP boosting index per Query orientation")+
      xlab('#boost index Q+ (log2)') +
    ylab('#boost index Q-(log2)') +
    coord_fixed(ratio = 1)

```

```{r, fig.width = 10, fig.height = 9}


BothOrientationsSplitbasal %>%
  #filter(class1== "PP")%>%
  group_by(frag1, class1)%>%
  summarise(n = dplyr::n(), MeanBoost1 = mean(boost1),MeanBoost2 = mean(boost2),
            activity_all_frag1.y=mean(activity_all_frag1.y),activity_all_frag1.x=mean(activity_all_frag1.x), class=unique(class1)) %>%
  filter(n>4)%>%
  mutate(ADiff = (log2(activity_all_frag1.x)-log2(activity_all_frag1.y)))%>%
  ggplot(aes(MeanBoost1,MeanBoost2, color=ADiff))+
   geom_jitter(size=0.5, aplpha=0.5)+
    facet_wrap(~class1)+
     geom_abline(slope=1)+
       stat_cor(method = "pearson")+
        stat_function(fun = (function(x)log2(2*2^(x))), colour = "black")+
      stat_function(fun = (function(x)log2(2^(x)/2)), colour = "black")+
    scale_color_gradient2(low = "navyblue", mid = "grey100", high = "red") +
  #scale_color_viridis(name = "log2(P+)-log2(P-)")+
      ggtitle("EP boosting index per Query orientation")+
      xlab('#boost index Q+ (log2)') +
    ylab('#boost index Q-(log2)') +
    coord_fixed(ratio = 1)

```
#### Rescaled

```{r}
#Rescale to median
MedianCombSplit <- tib_Split_avg %>%
  group_by(frag2) %>%
  summarise(medianComb=median(activity_all), MAD= mad(activity_all))

RescaledSplit <- left_join(tib_Split_avg,MedianCombSplit, by = "frag2" ) %>% mutate(BoostResc = log2(activity_all/medianComb))


#Match combinations with Query in both orientations
x1 <-RescaledSplit %>%
  filter(strand1=="+")%>%
  select(id,class,id1, frag1,strand1, id2,frag2, strand2, activity_all, activity_frag2_all, BoostResc)
y1<-RescaledSplit %>%
  filter(strand1=="-")%>%
  select(id,class,id1, frag1,strand1, id2,frag2, strand2, activity_all, activity_frag2_all, BoostResc)

 BothOrientationsSplitResc<-inner_join(x1,y1, by = c("id2", "frag1"), suffix = c("1","2") )


BothOrientationsSplitRescbasal <- left_join(BothOrientationsSplitResc,tibs_b2_Basal, by = c("id111" = "id" ))
BothOrientationsSplitRescbasal <- left_join(BothOrientationsSplitRescbasal,tibs_b2_Basal, by = c("id12" = "id" ))

```

```{r, fig.width = 10, fig.height = 9}


BothOrientationsSplitRescbasal %>%
  mutate(ADiff = (log2(activity_all_frag1.x)-log2(activity_all_frag1.y)))%>%
  ggplot(aes(BoostResc1,BoostResc2, color=ADiff))+
   geom_jitter(size=0.5, aplpha=0.5)+
    facet_wrap(~class1)+
     geom_abline(slope=1)+
       stat_cor(method = "pearson")+
        stat_function(fun = (function(x)log2(2*2^(x))), colour = "black")+
      stat_function(fun = (function(x)log2(2^(x)/2)), colour = "black")+
    scale_color_gradient2(low = "navyblue", mid = "grey100", high = "red") +
  #scale_color_viridis(name = "log2(P+)-log2(P-)")+
      ggtitle("EP boosting index per Query orientation")+
      xlab('#boost index Q+ (log2)') +
    ylab('#boost index Q-(log2)') +
    coord_fixed(ratio = 1)

```


#### Direct Ligation

```{r, fig.width = 10, fig.height = 9}
xD <-tibs_b2$comb_all %>%
  filter(class=="EP")%>%
  filter(strand1=="+")%>%
  select(id,class,id1, frag1,strand1, id2,frag2, strand2, activity_all, coop_add_all, boost_all)
yD<-tibs_b2$comb_all %>%
  filter(class=="EP")%>%
  filter(strand1=="-")%>%
  select(id,class,id1, frag1,strand1, id2,frag2, strand2, activity_all, coop_add_all, boost_all)

 BothOrientationsDirect<-inner_join(xD,yD, by = c("id2", "frag1"), suffix = c("1","2") )

 BothOrientationsDirect %>%
       filter(coop_add_all1!=-Inf)%>%
    filter(coop_add_all2!=-Inf)%>%
  ggplot(aes(log2(activity_all1),log2(activity_all2)))+
   geom_jitter(size=0.5, aplpha=0.5)+
     geom_abline(slope=1)+
       stat_cor(method = "pearson")+
        stat_function(fun = (function(x)log2(2*2^(x))), colour = "black")+
      stat_function(fun = (function(x)log2(2^(x)/2)), colour = "black")+
      ggtitle("EP Activity per Enhancer orientation")+
      xlab('#Activity E+ (log2)') +
    ylab('#Activity E-(log2)') +
    coord_fixed(ratio = 1)
```


```{r, fig.width = 20, fig.height = 18}
BothOrientationsDirect %>%
  filter(coop_add_all1!=-Inf)%>%
  filter(coop_add_all2!=-Inf)%>%
  ggplot(aes(log2(activity_all1),log2(activity_all2)))+
  geom_jitter(size=0.5, aplpha=0.5)+
  facet_wrap(~id2)+
  geom_abline(slope=1)+
  stat_cor(method = "pearson")+
  stat_function(fun = (function(x)log2(2*2^(x))), colour = "black")+
  stat_function(fun = (function(x)log2(2^(x)/2)), colour = "black")+
  ggtitle("EP Activity per Enhancer orientation")+
  xlab('#Activity E+ (log2)') +
  ylab('#Activity E-(log2)') +
  coord_fixed(ratio = 1)
```

```{r, fig.width = 20, fig.height = 18}
BothOrientationsDirect %>%
  filter(strand22=="+")%>%  
  filter(id11 %in% tib_Split_avg$id)%>%
  filter(coop_add_all1!=-Inf)%>%
  filter(coop_add_all2!=-Inf)%>%
  ggplot(aes(log2(activity_all1),log2(activity_all2)))+
  geom_jitter(size=0.5, aplpha=0.5)+
  facet_wrap(~id2)+
  geom_smooth(method="lm")+
  geom_abline(slope=1)+
  stat_cor(method = "pearson")+
  stat_function(fun = (function(x)log2(2*2^(x))), colour = "black")+
  stat_function(fun = (function(x)log2(2^(x)/2)), colour = "black")+
  ggtitle("EP Activity per Enhancer orientation")+
  xlab('#Activity E+ (log2)') +
  ylab('#Activity E-(log2)') +
  coord_fixed(ratio = 1)
```

```{r, fig.width = 20, fig.height = 18}
tibs_b2$comb_all %>%
  filter(class=="EP")%>%
  filter(strand2=="+")%>%  
  filter(id %in% tib_Split_avg$id)%>%
  ggplot(aes(log2(activity_br2),log2(activity_br3)))+
  geom_jitter(size=0.5, aplpha=0.5)+
  facet_wrap(~id2)+
  geom_abline(slope=1)+
  stat_cor(method = "pearson")+
  stat_function(fun = (function(x)log2(2*2^(x))), colour = "black")+
  stat_function(fun = (function(x)log2(2^(x)/2)), colour = "black")+
  ggtitle("EP Activity Br1vsBr2")+
  xlab('#Activity E+ (log2)') +
  ylab('#Activity E-(log2)') +
  coord_fixed(ratio = 1)
```


```{r, fig.width = 10, fig.height = 9}
 BothOrientationsDirect %>%
    filter(coop_add_all1!=-Inf)%>%
    filter(coop_add_all2!=-Inf)%>%
  ggplot(aes(boost_all1,boost_all2))+
       geom_jitter(size=0.5, aplpha=0.5)+
    ggtitle("EP Boosting index per Enhancer orientation")+
    xlab('#Boost index E+') +
    ylab('#Boost index E-') +
  geom_abline(slope=1)+
        geom_abline(slope=1, intercept =c(-1,0))+
    geom_abline(slope=1, intercept =c(1,0))+
    stat_cor(method = "pearson")+
    coord_fixed(ratio = 1)
```

#### Matched dataset Direct ligation
```{r, fig.width = 10, fig.height = 9}
 BothOrientationsDirect %>%
  filter(id11 %in% tib_Split_avg$id)%>%
  ggplot(aes(boost_all1,boost_all2))+
       geom_jitter(size=0.5, alpha=0.9)+
    ggtitle("EP Boosting index per Enhancer orientation")+
    xlab('#Boost index E+') +
    ylab('#Boost index E-') +
  geom_abline(slope=1)+
        geom_abline(slope=1, intercept =c(-1,0))+
    geom_abline(slope=1, intercept =c(1,0))+
    stat_cor(method = "pearson")+
    geom_smooth(method=lm)+
    coord_fixed(ratio = 1)
```

### Variance

Variance seems lower in Split design
```{r, fig.width = 20, fig.height = 18, echo=FALSE}

Combinatorial_ComparisonMerged %>%
  mutate(activity_br1_Split=log2(activity_br1_Split))%>%
  mutate(activity_br2_Split=log2(activity_br2_Split))%>%
  mutate(activity_br3_Split=log2(activity_br3_Split))%>%
 mutate(stDev = apply(.[(45:47)],1,sd))%>%
  ggplot(aes(log2(activity_all_split), sqrt(stDev))) +
   geom_jitter(size=1.5, alpha=0.5) +
    xlab('#Activity (log2)') +
    ylab('#sqrt(stDev)') +
  geom_smooth()+
    ggtitle("Comb Activity vs sqrt(stdev), Klf2 Split") +
    theme_bw(base_size=25) 

```

Variance goes down with activity but there is still quite some spread

```{r, fig.width = 20, fig.height = 18, echo=FALSE}

tibs_b2$comb%>%
  mutate(activity_br1=log2(activity_br1))%>%
  mutate(activity_br2=log2(activity_br2))%>%
  mutate(activity_br3=log2(activity_br3))%>%
 mutate(stDev = apply(.[(16:18)],1,sd))%>%
  ggplot(aes(log2(activity_all), sqrt(stDev))) +
   geom_jitter(size=1.5, alpha=0.5) +
    xlab('#Activity (log2)') +
    ylab('#sqrt(stDev)') +
  geom_smooth()+
    ggtitle("Comb Activity vs sqrt(stdev), Klf2 DAT-SuRE") +
    theme_bw(base_size=25) 

```

### more plots
Some other plots.
In this first one I computed the mean boosting index of all the combinations per enhancer to check if it has a generally activating or repressing effect.
```{r, fig.width = 50, fig.height = 15}
  tib_Split_avg %>%
  group_by(id1, frag1) %>%
  summarise(boostmean = mean(boost))%>%
  ggplot(aes(id1, boostmean, color=frag1))+
  geom_point(position = "dodge" , stat = "identity")+
  theme_bw(base_size = 15)
```
```{r, fig.width = 30, fig.height = 15}
  tib_Split_avg %>%
  mutate(BoostSign= ifelse(boost<0 , -1, 1))%>%
  group_by(frag1) %>%
  summarise(boosttrend = mean(BoostSign))%>%
  ggplot(aes(frag1, boosttrend, color=frag1))+
  geom_point(position = "dodge" , stat = "identity")+
  theme_bw(base_size = 15)
```

The following one, is the same data before doing the mean.
```{r, fig.width = 30, fig.height = 15}
  tib_Split_avg %>%
  ggplot(aes(frag1, boost, color=frag2))+
  geom_point(position = "dodge" , stat = "identity")+
  theme_bw(base_size = 20)
```


Check if basal activity is correlated with boosting index
```{r, fig.width = 20, fig.height = 18}
Combinatorial_ComparisonMerged %>%
ggplot(aes(boost_Split,log2(activity_all_frag1))) +
   geom_jitter(size=1.5, alpha=1, aes(color=frag2)) +
  facet_wrap(~class) +
    xlab('#comb activity Split') +
    ylab('#Basal activity Frag1 EP-SuRE') +
    ggtitle("Comb activity Split vs EP-SuRE") +
    theme_bw(base_size=25) + 
  geom_abline(slope=1)+
  stat_cor(method = "pearson")+
  geom_smooth(method = lm)+
    geom_hline(yintercept = 0)+
    geom_vline(xintercept = 0)+
    coord_fixed(ratio = 1)
```

Do the same for antisense transcription


### Find repetitive elements overlaping our Enhancers and promoters

While trying to find TFBSs that are found in the putative repressors, focusing on the stronger candidates like E30, I casually found that E30 is a repetitive element. E30 overlaps with an LTR (ERVK), which is embedded in a region full of retrotransposons between two genes. Seeing this coincidence I decided to systematically look for overlaps between repetitive elements and the elements in Klf2. Then I extended this analysis to the Nanog and Tfcp2l1 designs.

For this I downloaded the RepeatMasker data for mm10 from the repeat masker portal (http://www.repeatmasker.org/species/mm.html).


```{r}

#Load mm10 RepeatMasker data with biomartr, data downloaded from http://www.repeatmasker.org/species/mm.html

#BiocManager::install("biomartr")
library(biomartr)
RepMaskFull <- as_tibble(read_rm('~/mydata/Projects/EPmatrix/RepeatMasker/mm10.fa.out'))

#check names of different classes present
unique(RepMaskFull$matching_class)

#filter out low complexity, simple repeats, Satellites, tRNAs, rRNA, Other, and Unknown.
RepMaskFull_Filtered <-RepMaskFull%>% filter(!(matching_class %in% c("Simple_repeat", "Low_complexity", "Satellite", "Satellite/centr", "tRNA", "rRNA", "Other", "Unknown"))) 

#convert to Granges
#BiocManager::install("plyranges")
library(plyranges)

RepMaskFull_Filtered <- RepMaskFull %>% filter(!(matching_class %in% c("Simple_repeat", "Low_complexity", "Satellite", "Satellite/centr", "tRNA", "rRNA", "Other", "Unknown")))%>%
                                                 mutate(strand ="*") %>% dplyr::rename(start = qry_start,
                                                                                end = qry_end,
                                                                                width = qry_width,
                                                                                seqnames = qry_id) %>%
                                                select(seqnames, start, end, width, strand, repeat_id, matching_class, sw_score)

 
RepMaskFull_Gr <- as_granges(RepMaskFull_Filtered)

#Load Klf2 design as GRanges
klf2Bed <-  as_tibble(read_bed('~/mydata/GitLab/epmatrix/data/tad_deconstr_design/designs/fc180410_dat_klf2.bed'))

klf2Bed <-klf2Bed%>%mutate(prefix = str_sub(name, 1, 1),
           name = str_remove(name, '_.*'),
           name = str_remove(name, '[EP]'),
           name = str_pad(name, width = 3, pad = '0'),
           name = paste0(prefix, name)) %>%
    dplyr::select(-prefix)

klf2BedGr <-as_granges(klf2Bed)
  
# Find overlaps with join from plyranges
RepInnOverlap <- join_overlap_inner(klf2BedGr, RepMaskFull_Gr)
head(RepInnOverlap)
unique(RepInnOverlap$matching_class)

```


% of elements overlapping Repeats in Klf2 design
```{r}
#count how many elements overlap with repetitive elements
length(unique(RepInnOverlap$name))
#% of elements
100*length(unique(RepInnOverlap$name))/nrow(klf2Bed)
```

Do same analysisi for Tfcp2l1 anf Nanog designs
#### Tfcp2l1
```{r}
#Load Tfcp2l1 design as GRanges
Tfcp2l1Bed <-  as_tibble(read_bed('~/mydata/GitLab/epmatrix/data/tad_deconstr_design/designs/fc180419_dat_tfcp2l1.bed'))

Tfcp2l1Bed <-Tfcp2l1Bed%>%mutate(prefix = str_sub(name, 1, 1),
           name = str_remove(name, '_.*'),
           name = str_remove(name, '[EP]'),
           name = str_pad(name, width = 3, pad = '0'),
           name = paste0(prefix, name)) %>%
    dplyr::select(-prefix)

Tfcp2l1BedGr <-as_granges(Tfcp2l1Bed)
  
# Find overlaps with join from plyranges
Tfcp2l1RepInnOverlap <- join_overlap_inner(Tfcp2l1BedGr, RepMaskFull_Gr)
head(Tfcp2l1RepInnOverlap)
unique(Tfcp2l1RepInnOverlap$matching_class)
```

Quant
```{r}
#count how many elements overlap with repetitive elements
length(unique(Tfcp2l1RepInnOverlap$name))
#% of elements
100*length(unique(Tfcp2l1RepInnOverlap$name))/nrow(Tfcp2l1Bed)
```
#### Nanog
```{r}
#Load Tfcp2l1 design as GRanges
NanogBed <-  as_tibble(read_bed('~/mydata/GitLab/epmatrix/data/tad_deconstr_design/designs/fc180410_dat_nanog.bed'))

NanogBed <-NanogBed%>%mutate(prefix = str_sub(name, 1, 1),
           name = str_remove(name, '_.*'),
           name = str_remove(name, '[EP]'),
           name = str_pad(name, width = 3, pad = '0'),
           name = paste0(prefix, name)) %>%
    dplyr::select(-prefix)

NanogBedGr <-as_granges(NanogBed)
  
# Find overlaps with join from plyranges
NanogRepInnOverlap <- join_overlap_inner(NanogBedGr, RepMaskFull_Gr)
head(NanogRepInnOverlap)
unique(NanogRepInnOverlap$matching_class)
```

Quant
```{r}
#count how many elements overlap with repetitive elements
length(unique(NanogRepInnOverlap$name))
#% of elements
100*length(unique(NanogRepInnOverlap$name))/nrow(NanogBed)
```

Surprisingly 65-70% of the elements in the designs we made overlap with repetitive elements.
Next step is looking at if this influences the boosting ability of the elements.

#### Plot influence of repetitive elements on expression

Here I am exploring if the elements containing repeats have different boosting indexes and boosting trend than elements not containing repeats.
I do this analyisis for the Split design Data and for the EP-SuRE data.

BoostTrend measures the tendency of an enhancer to repress or activate. We group all combinations of a single Query element, to each combination we assign a value, 1 if it is boosted, and a -1 if it is repressed. Then we average the value for all the combinations of each Query element. This results in a value going from -1 to 1, where -1 means that the element is always repressing, 1 is always activating, and 0 is half of the time activating, half repressign. 


```{r, fig.width = 10, fig.height = 9}

#plot boosting trend and color elements in Repeats

  tib_Split_avg %>%
  mutate(BoostSign= ifelse(boost<0 , -1, 1))%>%
  group_by(frag1) %>%
  summarise(BoostTrend  = mean(BoostSign))%>%
  mutate(Masking= ifelse(frag1 %in% RepInnOverlap$name , "RepeatMasked", "Not"))%>%
  ggplot(aes(Masking, BoostTrend, fill=Masking))+
  geom_dotplot(binaxis = "y", stackdir = "center",binwidth = 0.05)+
    stat_summary(fun.y = median, fun.ymin = median, fun.ymax = median,
                 geom = "crossbar", width = 0.5)+
  theme_bw(base_size = 15)
```

```{r, fig.width = 10, fig.height = 9}

#plot boosting mean and color elements in Repeats

  tib_Split_avg %>%
  group_by(frag1) %>%
  summarise(boostmean = mean(boost))%>%
  mutate(Masking= ifelse(frag1 %in% RepInnOverlap$name , "RepeatMasked", "Not"))%>%
  ggplot(aes(Masking, boostmean, fill=Masking))+
  geom_dotplot(binaxis = "y", stackdir = "center",binwidth = 0.05)+
    stat_summary(fun.y = median, fun.ymin = median, fun.ymax = median,
                 geom = "crossbar", width = 0.5)+
  theme_bw(base_size = 15)
```

Do the same analysis splitting by each repeat type 

LTR
```{r}
#filter out low complexity, simple repeats, Satellites, tRNAs, rRNA, Other, and Unknown.
RepMaskFull_FilteredLTR <-RepMaskFull%>% filter((matching_class %in% c("LTR/ERVK","LTR/ERVL-MaLR","LTR/ERV1", "LTR/ERVL"))) 
#, "LTR/ERVK?"
#convert to Granges

RepMaskFull_FilteredLTR <- RepMaskFull_FilteredLTR %>% mutate(strand ="*") %>% dplyr::rename(start = qry_start ,
                                                                                   end = qry_end ,
                                                                                   width = qry_width,
                                                                                   seqnames = qry_id ) %>%
                                                select(seqnames, start, end, width, strand, repeat_id, matching_class, sw_score)

RepMaskFull_GrLTR <- as_granges(RepMaskFull_FilteredLTR)


# Find overlaps with join from plyranges
RepInnOverlapLTR <- join_overlap_inner(klf2BedGr, RepMaskFull_GrLTR)
head(RepInnOverlapLTR)

unique(RepInnOverlapLTR$name)

```


```{r}
#filter out low complexity, simple repeats, Satellites, tRNAs, rRNA, Other, and Unknown.
RepMaskFull_FilteredSine <-RepMaskFull%>% filter((matching_class %in% c("SINE/Alu", "SINE/B4", "SINE/B2"))) 
#without "SINE/ID", "SINE/MIR"
#convert to Granges

RepMaskFull_FilteredSine <- RepMaskFull_FilteredSine %>% mutate(strand ="*") %>% dplyr::rename(start = qry_start ,
                                                                                   end = qry_end ,
                                                                                   width = qry_width,
                                                                                   seqnames = qry_id ) %>%
                                                select(seqnames, start, end, width, strand, repeat_id, matching_class, sw_score)

RepMaskFull_GrSine <- as_granges(RepMaskFull_FilteredSine)


# Find overlaps with join from plyranges
RepInnOverlapSine<- join_overlap_inner(klf2BedGr, RepMaskFull_GrSine)
head(RepInnOverlapSine)

unique(RepInnOverlapLTR$name)

```

```{r, fig.width = 10, fig.height = 9}

#plot boosting trend and color elements in Repeats

  tib_Split_avg %>%
  mutate(BoostSign= ifelse(boost<0 , -1, 1))%>%
  group_by(frag1) %>%
  summarise(boosttrend = mean(BoostSign))%>%
  mutate(Masking= ifelse((frag1 %in% RepInnOverlapSine$name) & (frag1 %in%RepInnOverlapLTR$name) , "LTR & SINE" , ifelse(frag1 %in% RepInnOverlapSine$name , "SINE", ifelse(frag1 %in%RepInnOverlapLTR$name , "LTR", "Not"))))%>%
  ggplot(aes(Masking, boosttrend, fill=Masking))+
  geom_dotplot(binaxis = "y", stackdir = "center",binwidth = 0.05)+
    stat_summary(fun.y = median, fun.ymin = median, fun.ymax = median,
                 geom = "crossbar", width = 0.5)+
  theme_bw(base_size = 15)
```


```{r, fig.width = 10, fig.height = 9}

#plot boosting trend and color elements in Repeats

  tib_Split_avg %>%
  group_by(frag1) %>%
  summarise(boostmean = mean(boost))%>%
   mutate(Masking= ifelse((frag1 %in% RepInnOverlapSine$name) & (frag1 %in%RepInnOverlapLTR$name) , "LTR & SINE" , ifelse(frag1 %in% RepInnOverlapSine$name , "SINE", ifelse(frag1 %in%RepInnOverlapLTR$name , "LTR", "Not"))))%>%
  ggplot(aes(Masking, boostmean, fill=Masking))+
  geom_dotplot(binaxis = "y", stackdir = "center",binwidth = 0.05)+
    stat_summary(fun.y = median, fun.ymin = median, fun.ymax = median,
                 geom = "crossbar", width = 0.5)+
  theme_bw(base_size = 15)
```



EP-SuRE
```{r, fig.width = 10, fig.height = 9}
tibs_b2_klf2_EPSuRE$comb %>% 
    filter(frag2 %in% c("P001", "P009", "P013", "P014", "P016", "P017", "P018", "P019", "P021", "P022")) %>%
  filter(strand2=="+") %>%
  filter(class=="EP")%>% 
  group_by(frag1) %>%
  summarise(boostmean = mean(boost_all))%>%
   mutate(Masking= ifelse((frag1 %in% RepInnOverlapSine$name) & (frag1 %in%RepInnOverlapLTR$name) , "LTR & SINE" , ifelse(frag1 %in% RepInnOverlapSine$name , "SINE", ifelse(frag1 %in%RepInnOverlapLTR$name , "LTR", "Not"))))%>%
  ggplot(aes(Masking, boostmean, fill=Masking))+
  geom_dotplot(binaxis = "y", stackdir = "center",binwidth = 0.05)+
    stat_summary(fun.y = median, fun.ymin = median, fun.ymax = median,
                 geom = "crossbar", width = 0.5)+
  theme_bw(base_size = 15)
```



### TRIM28 regulated LTRs

We do the same analysis but using only the Repeat elements found to be regulated by Trim28 in Yang et al., cell 2015 (http://dx.doi.org/10.1016/j.cell.2015.08.037)(supp table s3j).

```{r}
#filter out low complexity, simple repeats, Satellites, tRNAs, rRNA, Other, and Unknown.
RepMaskFull_FilteredTrim28 <-RepMaskFull%>% filter((repeat_id %in% c("RLTR44D",
"MERVL-int",
"RLTR10B",
"RLTR10B2",
"LTR16D",
"MLT2E",
"MMERVK10C-int",
"MT2_Mm",
"RLTR6_Mm",
"IAPEy-int",
"RLTR10C",
"IAPLTR3-int",
'ORR1A1-int',
"LTR29",
"LTR77",
"MER70-int",
'LTR88b',
"IAPLTR1a_Mm",
"ORR1A3-int",
"MT2C_Mm",
"MMVL30-int",
"MERVL_2A-int",
"IAPEY3_LTR",
"RLTR9B2",
'ERVL-int',
'MuRRS-int',
'RLTR27',
'MER70B',
"MER65D",
"IAPEY3-int",
"IAPEz-int"))) 

#convert to Granges

RepMaskFull_FilteredTrim28 <- RepMaskFull_FilteredTrim28 %>% mutate(strand ="*") %>% dplyr::rename(start = qry_start ,
                                                                                   end = qry_end ,
                                                                                   width = qry_width,
                                                                                   seqnames = qry_id ) %>%
                                                select(seqnames, start, end, width, strand, repeat_id, matching_class, sw_score)

RepMaskFull_GrTrim28 <- as_granges(RepMaskFull_FilteredTrim28)


# Find overlaps with join from plyranges
RepInnOverlapTrim28 <- join_overlap_inner(klf2BedGr, RepMaskFull_GrTrim28)
head(RepInnOverlapTrim28)

unique(RepInnOverlapTrim28$name)

```

```{r, fig.width = 10, fig.height = 9}

#plot boosting mean and color elements in Repeats

  tib_Split_avg %>%
  group_by(frag1) %>%
  summarise(boostmean = mean(boost))%>%
  mutate(Masking= ifelse(frag1 %in% RepInnOverlapTrim28$name , "Trim28", "Not"))%>%
  ggplot(aes(Masking, boostmean, fill=Masking))+
  geom_dotplot(binaxis = "y", stackdir = "center",binwidth = 0.05)+
    stat_summary(fun.y = median, fun.ymin = median, fun.ymax = median,
                 geom = "crossbar", width = 0.5)+
  theme_bw(base_size = 15)
```


### Eset regulated LTRs

We do the same analysis but using only the Repeat elements found to be regulated by Eset in Yang et al., cell 2015 (http://dx.doi.org/10.1016/j.cell.2015.08.037)(supp table s3j).

```{r}
#filter out low complexity, simple repeats, Satellites, tRNAs, rRNA, Other, and Unknown.
RepMaskFull_FilteredEset <-RepMaskFull%>% filter((repeat_id %in% c("MMERGLN-int",
"RLTR1B",
"ETnERV3-int",
"MuLV-int",
"MERVL-int",
"MMERVK10C-int",
"LTR85c",
"RLTR10B",
"RLTR10C",
'RLTR4_Mm',
"MT2_Mm",
"RLTR4_MM-int",
"MLT2E",
"MMVL30-int",
'MURVY-int',
"RLTR13B2",
"RLTR10B2",
"IAPLTR3-int",
"RLTR6_Mm",
"RLTR45",
"RLTR1B-int",
"RLTR46",
"MER89",
"MuRRS4-int",
"RLTR9E",
"RMER16-int",
"BGLII",
"RLTR5_Mm",
"RLTR6-int",
"RLTR45-int",
"ORR1A0-int",
"RLTR9D",
"ORR1A1-int",
"RMER3D-int",
"RLTR1",
"MER57D",
"MER88",
"MER95",
"MER67D",
"LTR45C",
"LTR39",
"RLTR10E",
"LTR90B",
"IAPLTR4",
"RLTR9B2",
"MER65D",
"ORR1A0",
"IAPLTR3",
"RLTR13B1",
"MuRRS-int",
"RLTR13D6",
"ORR1A3-int",
"RLTR9A",
"RLTR10-int",
"MurERV4_19-int",
"LTR65",
"IAPLTR4_I",
'MURVY-LTR',
"LTRIS_Mm",
"LTRIS2",
"RLTR13D3",
"LTR55",
"RLTR10",
"RLTR9A2",
"MLT1G3-int",
"IAPLTR1a_Mm",
"MMTV-int",
"RLTR43A"))) 

#convert to Granges

RepMaskFull_FilteredEset <- RepMaskFull_FilteredEset %>% mutate(strand ="*") %>% dplyr::rename(start = qry_start ,
                                                                                   end = qry_end ,
                                                                                   width = qry_width,
                                                                                   seqnames = qry_id ) %>%
                                                select(seqnames, start, end, width, strand, repeat_id, matching_class, sw_score)

RepMaskFull_GrEset <- as_granges(RepMaskFull_FilteredEset)


# Find overlaps with join from plyranges
RepInnOverlapEset <- join_overlap_inner(klf2BedGr, RepMaskFull_GrEset)
head(RepInnOverlapEset)

unique(RepInnOverlapEset$name)

```

```{r, fig.width = 10, fig.height = 9}

#plot boosting mean and color elements in Repeats

  tib_Split_avg %>%
  group_by(frag1) %>%
  summarise(boostmean = mean(boost))%>%
  mutate(Masking= ifelse(frag1 %in% RepInnOverlapEset$name , "Eset", "Not"))%>%
  ggplot(aes(Masking, boostmean, fill=Masking))+
  geom_dotplot(binaxis = "y", stackdir = "center",binwidth = 0.05)+
    stat_summary(fun.y = median, fun.ymin = median, fun.ymax = median,
                 geom = "crossbar", width = 0.5)+
  theme_bw(base_size = 15)
```

